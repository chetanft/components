#!/usr/bin/env node
/**
 * Sync Storybook stories into ft-docs for direct imports.
 *
 * - Creates lightweight re-export stubs under ft-docs/src/components
 * - Generates ft-docs/src/lib/story-manifest.ts with component â†’ import map
 */

const fs = require('fs');
const path = require('path');

const projectRoot = path.join(__dirname, '..');
const srcDir = path.join(projectRoot, 'src');
const ftDocsDir = path.join(projectRoot, 'ft-docs');
const docsComponentsDir = path.join(ftDocsDir, 'src', 'components');
const docsConfigPath = path.join(ftDocsDir, 'src', 'config', 'docs.ts');
const storyLoaderPath = path.join(ftDocsDir, 'src', 'lib', 'story-loader.ts');
const manifestPath = path.join(ftDocsDir, 'src', 'lib', 'story-manifest.ts');

const STORY_EXT = '.stories.tsx';

const slugToName = (slug) => slug
  .split('-')
  .map((part) => part ? part[0].toUpperCase() + part.slice(1) : '')
  .join('');

const readDocsComponents = () => {
  if (!fs.existsSync(docsConfigPath)) return [];
  const content = fs.readFileSync(docsConfigPath, 'utf8');
  const regex = /href:\s*["']\/docs\/components\/([^"']+)["']/g;
  const names = new Set();
  let match;
  while ((match = regex.exec(content))) {
    names.add(slugToName(match[1]));
  }
  return Array.from(names);
};

const readExistingStoryKeys = () => {
  const sources = [manifestPath, storyLoaderPath];
  const names = new Set();
  const regex = /'([^']+)'\s*:\s*\(\) =>/g;

  sources.forEach((source) => {
    if (!fs.existsSync(source)) return;
    const content = fs.readFileSync(source, 'utf8');
    let match;
    while ((match = regex.exec(content))) {
      names.add(match[1]);
    }
  });

  return Array.from(names);
};

const collectStoryFiles = () => {
  const storyRoots = [path.join(srcDir, 'components'), path.join(srcDir, 'stories')];
  const files = [];

  const walk = (dir) => {
    if (!fs.existsSync(dir)) return;
    for (const entry of fs.readdirSync(dir)) {
      const entryPath = path.join(dir, entry);
      const stat = fs.statSync(entryPath);
      if (stat.isDirectory()) {
        walk(entryPath);
      } else if (entry.endsWith(STORY_EXT)) {
        const relFromSrc = path.relative(srcDir, entryPath);
        const relParts = relFromSrc.split(path.sep);
        const trimmedParts = relParts[0] === 'components' ? relParts.slice(1) : relParts.slice();
        const relDocs = trimmedParts.join(path.sep);
        const relDocsNoExt = relDocs.replace(/\.tsx$/, '');
        files.push({
          absPath: entryPath,
          relFromSrc,
          relDocs,
          relDocsNoExt,
          baseName: path.basename(entry, STORY_EXT),
          parentDir: path.basename(path.dirname(entryPath)),
          aliasImport: `@chetanft/design_system/${relFromSrc.replace(/\\/g, '/').replace(/\.tsx$/, '')}`,
          manifestPath: `../components/${relDocs.replace(/\\/g, '/').replace(/\.tsx$/, '')}`,
          destPath: path.join(docsComponentsDir, relDocs),
        });
      }
    }
  };

  storyRoots.forEach(walk);
  return files;
};

const ensureStubFiles = (stories) => {
  stories.forEach((story) => {
    const dir = path.dirname(story.destPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const relativeImportPath = path.relative(dir, story.absPath)
      .replace(/\\/g, '/')
      .replace(/\.tsx$/, '');
    const normalizedImport = relativeImportPath.startsWith('.')
      ? relativeImportPath
      : `./${relativeImportPath}`;

    const stub = `export { default } from '${normalizedImport}';\nexport * from '${normalizedImport}';\n`;
    const exists = fs.existsSync(story.destPath)
      ? fs.readFileSync(story.destPath, 'utf8')
      : null;

    if (exists !== stub) {
      fs.writeFileSync(story.destPath, stub, 'utf8');
    }
  });
};

const selectStoryForComponent = (name, stories) => {
  const candidates = stories.filter((story) => story.baseName === name);
  if (candidates.length === 0) return null;

  const lowerName = name.toLowerCase();
  return (
    candidates.find((story) => story.parentDir.toLowerCase() === lowerName) ||
    candidates.find((story) => story.relFromSrc.startsWith(`components${path.sep}`)) ||
    candidates[0]
  );
};

const writeManifest = (entries) => {
  const header = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/sync-doc-stories.cjs\n\nexport type StoryLoader = () => Promise<any>;\n\nexport const storyPathMap: Record<string, StoryLoader> = {\n`;
  const body = entries
    .map(({ name, importPath }) => `  '${name}': () => import('${importPath}'),`)
    .join('\n');
  const footer = '\n};\n';

  fs.writeFileSync(manifestPath, `${header}${body}${footer}`, 'utf8');
};

(function syncStories() {
  const docsNames = readDocsComponents();
  const existingMap = readExistingStoryKeys();
  const targetNames = Array.from(new Set([...docsNames, ...existingMap])).sort((a, b) => a.localeCompare(b));

  const stories = collectStoryFiles();
  ensureStubFiles(stories);

  const manifestEntries = [];
  const missing = [];

  targetNames.forEach((name) => {
    const story = selectStoryForComponent(name, stories);
    if (!story) {
      missing.push(name);
      return;
    }
    manifestEntries.push({ name, importPath: story.manifestPath });
  });

  manifestEntries.sort((a, b) => a.name.localeCompare(b.name));
  writeManifest(manifestEntries);

  console.log(`Synced ${stories.length} story files.`);
  console.log(`Generated manifest with ${manifestEntries.length} entries.`);

  if (missing.length > 0) {
    console.warn('Missing stories for components:', missing.join(', '));
  }
})();
