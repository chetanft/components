import fs from 'fs';
import path from 'path';
import { transform } from '@babel/standalone';

// Cache for metadata
const metadataCache = new Map<string, ComponentDoc>();
let componentNamesCache: string[] | null = null; // Will be computed on first call

// Export function to clear cache (useful for development)
export function clearMetadataCache() {
  metadataCache.clear();
  componentNamesCache = null;
}

// Paths - resolve relative to project root
// In Next.js, process.cwd() is the project root (ft-docs)
// We need to go up to the components root
function getProjectRoot(): string {
  const cwd = process.cwd();

  // Check if we're in ft-docs directory
  if (path.basename(cwd) === 'ft-docs') {
    return path.resolve(cwd, '..');
  }

  // Check if we're already in components root
  const componentsIndex = path.join(cwd, 'src', 'components', 'index.ts');
  if (fs.existsSync(componentsIndex)) {
    return cwd;
  }

  // Try going up from ft-docs
  const possibleRoot = path.resolve(cwd, '..');
  const possibleIndex = path.join(possibleRoot, 'src', 'components', 'index.ts');
  if (fs.existsSync(possibleIndex)) {
    return possibleRoot;
  }

  // Fallback - assume we're in components root
  return cwd;
}

const projectRoot = getProjectRoot();
const srcComponentsDir = path.join(projectRoot, 'src', 'components');
const srcStoriesDir = path.join(projectRoot, 'src', 'stories');
const componentsIndexPath = path.join(srcComponentsDir, 'index.ts');

export type ComponentDoc = {
  description: string;
  import: string;
  props: Record<string, {
    type: string;
    required: boolean;
    description: string;
    default?: string;
  }>;
  examples: Array<{
    name: string;
    code: string;
  }>;
};

/**
 * Extract variant key from code to prevent duplicates
 */
function extractVariantKey(code: string, componentName: string): string {
  const variantMatch = code.match(/variant=["']([^"']+)["']/);
  const sizeMatch = code.match(/size=["']([^"']+)["']/);
  const stateMatch = code.match(/state=["']([^"']+)["']/);
  const iconMatch = code.match(/icon=["']([^"']+)["']/);
  const leadingIconMatch = code.match(/leadingIcon=["']([^"']+)["']/);
  const trailingIconMatch = code.match(/trailingIcon=["']([^"']+)["']/);
  const interactionMatch = code.match(/\binteraction\b/);
  const hasDisabled = /\bdisabled\b/.test(code);
  const hasChecked = /\bchecked\b/.test(code);
  const hasError = /\berror\b/.test(code);

  const keyParts = [componentName];
  if (variantMatch) keyParts.push(`variant:${variantMatch[1]}`);
  if (sizeMatch) keyParts.push(`size:${sizeMatch[1]}`);
  if (stateMatch) keyParts.push(`state:${stateMatch[1]}`);
  if (iconMatch) keyParts.push(`icon:${iconMatch[1]}`);
  if (leadingIconMatch) keyParts.push(`leadingIcon:${leadingIconMatch[1]}`);
  if (trailingIconMatch) keyParts.push(`trailingIcon:${trailingIconMatch[1]}`);
  if (interactionMatch) keyParts.push('interaction');
  if (hasDisabled) keyParts.push('disabled');
  if (hasChecked) keyParts.push('checked');
  if (hasError) keyParts.push('error');

  return keyParts.join('|');
}

function formatArrayLiteral(arrayLiteral: string): string {
  try {
    // eslint-disable-next-line no-new-func
    const parsed = new Function(`return (${arrayLiteral});`)();
    if (!Array.isArray(parsed)) {
      return arrayLiteral;
    }
    // Format as single line for react-live compatibility
    return JSON.stringify(parsed)
      .replace(/"([^"]+)":/g, '$1:')
      .replace(/"([^"]*)"/g, "'$1'");
  } catch {
    return arrayLiteral;
  }
}

/**
 * Component-specific Figma patterns
 */
const componentPatterns: Record<string, RegExp[]> = {
  Button: [
    /^(Primary|Secondary|Tertiary|Destructive|Text|Link)$/,
    /^(Primary|Secondary|Tertiary|Destructive|Text|Link)\s+(Disabled|Loading)$/,
    /^(Primary|Secondary|Tertiary|Destructive|Text|Link)\s+With\s+(Leading|Trailing)\s+Icon$/,
    /^Icon\s+Only$/,
    // Size variants (part of design system)
    /^(Extra\s+Small|Small|Medium|Large|Extra\s+Large|2X\s+Large)$/i,
    // Circular buttons (rounded-full styling)
    /^Circular\s+Buttons?$/i,
  ],
  Checkbox: [
    /^(Default|Small|Checked|Indeterminate|With\s+Description|Error|Disabled|Disabled\s+Checked)$/i,
  ],
  Switch: [
    /^(Checked|Unchecked)$/,
    /^(Checked|Unchecked)\s+Disabled$/,
    /^Without\s+Label$/,
  ],
  Badge: [
    /^(Normal|Danger|Success|Warning|Neutral)$/,
    /^With (Leading|Trailing) Icon$/i,
    /^With Both Icons$/i,
    /^Interactive$/i,
  ],
  Tabs: [
    /^(Primary|Secondary|Tertiary)$/,
    /^FigmaVariants/,
  ],
  Label: [
    /^(Default|With\s+Suffix\s+Icon|Optional|Optional\s+With\s+Icon|Mandatory|Mandatory\s+With\s+Icon|Custom\s+Icon|Long\s+Text)$/i,
  ],
  Input: [
    // Figma-approved variants only
    /^(Default|Error|Disabled|Filled|Warning|Success)$/,
    /^(Default|Hover|Focused|Typing|Filled|Disabled|Prefilled)$/i,
    // Sizes are in Figma (xxs, xs, sm, md, lg, xl, xxl)
    /^(Sizes|Variants|States)$/,
    // Label variants (Mandatory, Optional, WithSuffixIcon are label features, not input variants)
    /^(Mandatory|Optional|WithSuffixIcon|WithCustomIcon|MandatoryWithIcon|OptionalWithIcon)$/,
  ],
  Dropdown: [
    // Figma-approved variants only
    /^(Default|Error|Disabled)$/,
    // Sizes and States are in Figma
    /^(Sizes|States)$/,
  ],
  DatePicker: [
    // Figma-approved variants only
    /^(Default|Disabled|WithError|WithValue)$/i,
    // Sizes are in Figma
    /^(AllSizes|Sizes)$/i,
    // DateRange might be in Figma, but need to verify
    // /^(DateRange|DateRangeWithValues)$/i,
  ],
};

/**
 * Check if variant name matches Figma patterns
 */
function isFigmaVariantName(name: string, componentName: string): boolean {
  // Explicit Figma story names
  if (/FigmaVariants|FigmaDesign|FigmaTimeline|figma/i.test(name)) {
    return true;
  }

  // Component-specific Figma patterns (check these first)
  if (componentPatterns[componentName]) {
    for (const pattern of componentPatterns[componentName]) {
      if (pattern.test(name)) {
        return true;
      }
    }
  }

  // Generic patterns
  if (/^Default$/.test(name)) {
    return true;
  }

  return false;
}

/**
 * Find component file path
 */
function findComponentFile(componentName: string): string | null {
  // Handle special folder naming cases (e.g., Logo component is in Logos folder)
  const folderVariants = [componentName];
  if (componentName === 'Logo') {
    folderVariants.push('Logos');
  }

  for (const folder of folderVariants) {
    const possiblePaths = [
      path.join(srcComponentsDir, 'atoms', folder, `${componentName}.tsx`),
      path.join(srcComponentsDir, 'atoms', folder, `${componentName}.ts`),
      path.join(srcComponentsDir, 'molecules', folder, `${componentName}.tsx`),
      path.join(srcComponentsDir, 'molecules', folder, `${componentName}.ts`),
      path.join(srcComponentsDir, 'organisms', folder, `${componentName}.tsx`),
      path.join(srcComponentsDir, 'organisms', folder, `${componentName}.ts`),
    ];

    for (const filePath of possiblePaths) {
      if (fs.existsSync(filePath)) {
        return filePath;
      }
    }
  }

  return null;
}

/**
 * Find story file path
 */
function findStoryFile(componentName: string): string | null {
  // Handle special folder naming cases (e.g., Logo component is in Logos folder)
  const folderVariants = [componentName];
  if (componentName === 'Logo') {
    folderVariants.push('Logos');
  }

  // Check in component directory first
  for (const folder of folderVariants) {
    const componentStoryPaths = [
      path.join(srcComponentsDir, 'atoms', folder, `${componentName}.stories.tsx`),
      path.join(srcComponentsDir, 'molecules', folder, `${componentName}.stories.tsx`),
      path.join(srcComponentsDir, 'organisms', folder, `${componentName}.stories.tsx`),
    ];

    for (const storyPath of componentStoryPaths) {
      if (fs.existsSync(storyPath)) {
        return storyPath;
      }
    }
  }

  // Check in src/stories
  const storiesPath = path.join(srcStoriesDir, `${componentName}.stories.tsx`);
  if (fs.existsSync(storiesPath)) {
    return storiesPath;
  }

  return null;
}

/**
 * Extract props from TypeScript component file
 */
function extractPropsFromComponent(componentPath: string, componentName: string): Record<string, any> {
  const content = fs.readFileSync(componentPath, 'utf-8');
  const props: Record<string, any> = {};

  // Extract interface/type definition
  const interfacePattern = new RegExp(
    `export\\s+(interface|type)\\s+${componentName}Props[^{]*\\{([^}]+(?:\\{[^}]*\\}[^}]*)*)\\}`,
    's'
  );
  const match = content.match(interfacePattern);

  if (match) {
    const interfaceContent = match[2];
    // Extract prop definitions: propName?: type;
    const propPattern = /(\w+)\??:\s*([^;]+);/g;
    let propMatch;

    while ((propMatch = propPattern.exec(interfaceContent)) !== null) {
      const propName = propMatch[1];
      const propType = propMatch[2].trim();
      const isRequired = !propMatch[0].includes('?');

      props[propName] = {
        type: propType,
        required: isRequired,
        description: '',
      };
    }
  }

  // Always add className if not present
  if (!props.className) {
    props.className = {
      type: 'string',
      required: false,
      description: 'Additional CSS classes',
    };
  }

  return props;
}

/**
 * Extract props from Storybook argTypes
 */
function extractPropsFromStory(content: string): Record<string, any> {
  const props: Record<string, any> = {};

  // Find argTypes block - using [\s\S] instead of . with /s flag for ES2017 compatibility
  const argTypesMatch = content.match(/argTypes:\s*\{([\s\S]+?)\}/);
  if (!argTypesMatch) {
    return props;
  }

  const argTypesContent = argTypesMatch[1];

  // Extract individual prop definitions
  const propPattern = /(\w+):\s*\{([^}]+(?:\{[^}]*\}[^}]*)*)\}/g;
  let propMatch;

  while ((propMatch = propPattern.exec(argTypesContent)) !== null) {
    const propName = propMatch[1];
    const propContent = propMatch[2];

    const propInfo: any = {
      type: 'any',
      required: false,
      description: '',
    };

    // Extract description
    const descMatch = propContent.match(/description:\s*["']([^"']+)["']/);
    if (descMatch) {
      propInfo.description = descMatch[1];
    }

    // Extract control type
    const controlMatch = propContent.match(/control:\s*\{?\s*type:\s*["']?(\w+)["']?/);
    if (controlMatch) {
      const controlType = controlMatch[1];
      if (controlType === 'select') {
        const optionsMatch = propContent.match(/options:\s*\[([^\]]+)\]/);
        if (optionsMatch) {
          const options = optionsMatch[1].split(',').map((o) => o.trim().replace(/['"]/g, ''));
          propInfo.type = `union of ${options.map((o) => `'${o}'`).join(', ')}`;
        } else {
          propInfo.type = 'select';
        }
      } else {
        propInfo.type = controlType;
      }
    }

    // Extract default value
    const defaultMatch = propContent.match(/defaultValue:\s*["']?([^"'\s,}]+)["']?/);
    if (defaultMatch) {
      propInfo.default = defaultMatch[1];
    }

    props[propName] = propInfo;
  }

  // Always add className if not present
  if (!props.className) {
    props.className = {
      type: 'string',
      required: false,
      description: 'Additional CSS classes',
    };
  }

  return props;
}

/**
 * Extract complete function body from function-based story export
 */
function extractFunctionBody(content: string, matchArray: RegExpMatchArray, startPos: number): string | null {
  const isFunctionDeclaration = matchArray[2] !== undefined; // match[2] is set for export function
  
  if (isFunctionDeclaration) {
    // For: export function StoryName() { ... }
    // The opening brace is already included in the regex match, so function body starts at startPos
    let braceCount = 1; // We're already inside the opening brace
    let pos = startPos;
    
    while (pos < content.length && braceCount > 0) {
      if (content[pos] === '{') braceCount++;
      else if (content[pos] === '}') {
        braceCount--;
        if (braceCount === 0) {
          return content.substring(startPos, pos).trim();
        }
      }
      pos++;
    }
  } else {
    // For: export const StoryName = () => { ... } OR export const StoryName = () => ( ... )
    // Find the arrow function start
    const arrowMatch = content.substring(matchArray.index!, startPos + 200).match(/=\s*\([^)]*\)\s*=>\s*([({])/);
    if (!arrowMatch) return null;
    
    const arrowStartPos = (matchArray.index! || 0) + arrowMatch.index! + arrowMatch[0].length;
    const isParens = arrowMatch[1] === '(';
    const isBrace = arrowMatch[1] === '{';
    
    if (isParens) {
      // () => ( ... )
      let parenCount = 1;
      let pos = arrowStartPos;
      
      while (pos < content.length && parenCount > 0) {
        if (content[pos] === '(') parenCount++;
        else if (content[pos] === ')') {
          parenCount--;
          if (parenCount === 0) {
            return content.substring(arrowStartPos, pos).trim();
          }
        }
        pos++;
      }
    } else if (isBrace) {
      // () => { ... }
      // Extract the complete function body (including hooks, variables, return statement)
      let braceCount = 1;
      let pos = arrowStartPos;
      
      while (pos < content.length && braceCount > 0) {
        if (content[pos] === '{') braceCount++;
        else if (content[pos] === '}') {
          braceCount--;
          if (braceCount === 0) {
            // Return the complete body content (hooks, variables, return statement)
            return content.substring(arrowStartPos, pos).trim();
          }
        }
        pos++;
      }
    }
  }
  
  return null;
}

/**
 * Transpile TypeScript function code to JavaScript
 * Strips type annotations while preserving logic and JSX
 */
function transpileTypeScript(tsCode: string): string {
  // Use regex-based type stripping to preserve JSX
  // This is simpler and more reliable than Babel for our use case
  // since react-live needs JSX, not React.createElement calls
  
  let jsCode = tsCode;
  
  // Strip TypeScript type annotations while preserving JSX
  // IMPORTANT: Don't remove object property values like `disabled: true`
  // Only remove type annotations (capitalized words like Type, String, Number)
  // NOT values (true, false, 123, 'string')
  jsCode = jsCode
    // Remove array type annotations: Array<'xs' | 'sm' | ...>
    .replace(/:\s*Array<[^>]+>/g, '')
    // Remove union type annotations: 'xs' | 'sm' | 'md'
    .replace(/:\s*['"][^'"]+['"](\s*\|\s*['"][^'"]+['"])+/g, '')
    // Remove generic type annotations: React.FC<Props>
    .replace(/:\s*\w+<[^>]+>/g, '')
    // Remove React type annotations: : React.ReactNode, : React.FC
    .replace(/:\s*React\.\w+/g, '')
    // Remove function return type annotations: ): Type => or ): Type {
    // Only match capitalized type names, not values
    .replace(/\)\s*:\s*([A-Z]\w*)/g, ')')
    // Remove type annotations in variable declarations: const x: Type = ...
    // Match capitalized type names only (Type, String, Number, etc.)
    // NOT values (true, false, 123)
    .replace(/(const|let|var)\s+(\w+)\s*:\s*([A-Z]\w*)\s*=/g, '$1 $2 =')
    // Remove type annotations after function parameters: (x: Type) => ...
    // Only match capitalized type names, preserve values
    .replace(/\(([^)]+)\)/g, (match, params) => {
      // Only remove type annotations (capitalized words), not values
      return '(' + params.replace(/:\s*([A-Z]\w*)/g, '') + ')';
    })
    // Fix JSX attribute spacing: className = "..." -> className="..."
    .replace(/(\w+)\s*=\s*(["'])/g, '$1=$2')
    // Fix JSX expression spacing: prop = {value} -> prop={value}
    .replace(/(\w+)\s*=\s*(\{)/g, '$1=$2')
    // Clean up any double spaces (but preserve single spaces in JSX)
    .replace(/[ \t]{2,}/g, ' ')
    .trim();
  
  return jsCode;
}

/**
 * Extract examples from Storybook story file
 */
function extractExamplesFromStory(storyPath: string, componentName: string): Array<{ name: string; code: string }> {
  const content = fs.readFileSync(storyPath, 'utf-8');
  const examples: Array<{ name: string; code: string }> = [];
  const seenCodes = new Set<string>();
  const seenVariantKeys = new Set<string>();

  // Find all story exports (both Story type and function exports)
  // Matches: export const StoryName = () => {...} OR export function StoryName() {...} OR export const StoryName: Story = {...}
  const storyExports = Array.from(content.matchAll(/export\s+(?:const\s+(\w+)\s*(?::\s*Story\s*=\s*\{|=.*\(\)\s*=>)|function\s+(\w+)\s*\([^)]*\)\s*\{)/g));

  // Separate Figma stories from regular stories, and function exports from args-based
  const figmaStories: RegExpMatchArray[] = [];
  const regularStories: RegExpMatchArray[] = [];
  const functionStories: RegExpMatchArray[] = [];

  for (const match of storyExports) {
    const matchArray = match as RegExpMatchArray;
    // For export const: match[1] has the name, match[2] is undefined
    // For export function: match[1] is undefined, match[2] has the name
    const storyName = (matchArray[1] || matchArray[2]) as string;
    if (!storyName) continue; // Skip if we can't extract the name
    
    // Check if this is a function export
    const isFunctionDeclaration = matchArray[2] !== undefined; // match[2] is set for export function
    const matchText = content.substring(matchArray.index!, matchArray.index! + matchArray[0].length + 100);
    const isArrowFunction = matchText.includes('= () =>') || matchText.includes('=()=>');
    const isFunctionExport = isFunctionDeclaration || isArrowFunction;
    
    // Skip AllVariants/AllStates stories that aren't Figma (they create duplicates)
    if ((/AllVariants|AllStates/i.test(storyName) || /^all$/i.test(storyName)) && !/Figma|figma/i.test(storyName)) {
      continue;
    }
    
    if (isFunctionExport) {
      // Function-based stories (Sizes, States, InteractiveDemo, etc.)
      functionStories.push(matchArray);
    } else if (/Figma|figma/i.test(storyName)) {
      figmaStories.push(matchArray);
    } else {
      // Args-based stories
      regularStories.push(matchArray);
    }
  }

  // Process function stories first (they're often consolidated views), then regular stories, then Figma stories
  // This ensures consolidated views are shown, individual variants are shown, and FigmaVariants only if no others exist
  const storiesToProcess = functionStories.length > 0 
    ? [...functionStories, ...regularStories, ...figmaStories]
    : regularStories.length > 0 
      ? regularStories 
      : figmaStories;

  for (const match of storiesToProcess) {
    const matchArray = match as RegExpMatchArray;
    // For export const: match[1] has the name, match[2] is undefined
    // For export function: match[1] is undefined, match[2] has the name
    const storyName = (matchArray[1] || matchArray[2]) as string;
    if (!storyName) continue; // Skip if we can't extract the name
    const startPos = matchArray.index! + matchArray[0].length;

    // Check if this is a function export
    const isFunctionDeclaration = matchArray[2] !== undefined; // match[2] is set for export function
    const matchText = content.substring(matchArray.index!, startPos + 100);
    const isArrowFunction = matchText.includes('= () =>') || matchText.includes('=()=>');
    const isFunctionExport = isFunctionDeclaration || isArrowFunction;

    // Handle function-based stories
    if (isFunctionExport) {
      const functionBody = extractFunctionBody(content, matchArray, startPos);
      if (!functionBody) {
        console.warn(`[${componentName}] Failed to extract function body for ${storyName}`);
        continue;
      }

      // Transpile TypeScript to JavaScript
      // The function body should include hooks, variables, and return statement
      let jsCode = transpileTypeScript(functionBody);
      
      // ComponentPreview checks if code starts with 'function' and uses it as-is
      // However, react-live executes code and expects a React element
      // For functions, react-live won't automatically call them
      // Solution: Extract JSX for simple functions, use IIFE for hooks
      
      const hasHooks = jsCode.includes('useState') || jsCode.includes('useEffect') || jsCode.includes('useRef');
      const hasReturn = jsCode.includes('return');
      const hasVariables = /(const|let|var)\s+\w+\s*=/.test(jsCode);
      
      if (hasHooks || (hasVariables && hasReturn)) {
        // Functions with hooks OR variables must stay as functions
        // CRITICAL: React hooks can only be called inside React function components
        // Variables need to be in scope for the JSX
        // Format: (() => { const Component = () => { vars/hooks; return jsx; }; return <Component />; })()
        // This ensures hooks/variables are inside a React component context
        
        if (jsCode.trim().startsWith('function')) {
          // Extract function body and wrap in component inside IIFE
          const bodyMatch = jsCode.match(/function\s+\w+\s*\([^)]*\)\s*\{([\s\S]*)\}/);
          if (bodyMatch) {
            const functionBody = bodyMatch[1].trim();
            // Wrap function body in a component function, then IIFE
            const indentedBody = functionBody.split('\n').map(line => {
              const originalIndent = line.match(/^(\s*)/)?.[1] || '';
              return '    ' + originalIndent + line.trim();
            }).join('\n');
            // IIFE with component wrapper - hooks/variables are inside Component function
            jsCode = `(() => {\n  const ${storyName} = () => {\n${indentedBody}\n  };\n  return <${storyName} />;\n})()`;
          } else {
            const indentedCode = jsCode.split('\n').map(line => `    ${line}`).join('\n');
            jsCode = `(() => {\n  const ${storyName} = () => {\n${indentedCode}\n  };\n  return <${storyName} />;\n})()`;
          }
        } else {
          // Function body - wrap in component function, then IIFE
          const indentedBody = jsCode.split('\n').map(line => {
            const originalIndent = line.match(/^(\s*)/)?.[1] || '';
            return '    ' + originalIndent + line.trim();
          }).join('\n');
          // IIFE with component wrapper - hooks/variables are inside Component function
          jsCode = `(() => {\n  const ${storyName} = () => {\n${indentedBody}\n  };\n  return <${storyName} />;\n})()`;
        }
      } else if (hasReturn) {
        // Simple function - extract just the JSX return value
        // ComponentPreview will wrap it in function Preview() { return (...) }
        const returnMatch = jsCode.match(/return\s*\(([\s\S]*?)\)\s*;?\s*$/);
        if (returnMatch) {
          jsCode = returnMatch[1].trim();
        } else {
          // Fallback: try to extract JSX after return
          const returnIndex = jsCode.indexOf('return');
          if (returnIndex !== -1) {
            let afterReturn = jsCode.substring(returnIndex + 6).trim();
            // Remove leading ( and trailing ); if present
            afterReturn = afterReturn.replace(/^\(/, '').replace(/\);?\s*$/, '').trim();
            jsCode = afterReturn;
          }
        }
      }
      // If no return/hooks, it's already JSX - use as-is
      
      // Generate display name from story name
      let displayName = storyName.replace(/([A-Z])/g, ' $1').trim();
      if (storyName === 'InteractiveDemo') {
        displayName = 'Interactive Demo';
      } else if (storyName === 'Sizes') {
        displayName = 'Sizes';
      } else if (storyName === 'States') {
        displayName = 'States';
      }

      // Check for duplicates
      const codeKey = jsCode.replace(/\s+/g, '');
      const duplicateKey = `${storyName}|${codeKey}`;
      if (seenCodes.has(duplicateKey)) {
        continue;
      }

      seenCodes.add(duplicateKey);
      examples.push({ name: displayName, code: jsCode });
      continue; // Skip args extraction for function exports
    }

    // Handle args-based stories (existing logic)
    // Find the matching closing brace
    let braceCount = 1;
    let pos = startPos;
    let endPos = content.length;

    while (pos < content.length && braceCount > 0) {
      if (content[pos] === '{') braceCount++;
      else if (content[pos] === '}') {
        braceCount--;
        if (braceCount === 0) {
          endPos = pos + 1;
          break;
        }
      }
      pos++;
    }

    const storyContent = content.substring(startPos, endPos);

    // Skip AllVariants stories that aren't Figma (they create duplicates)
    // Match "all" only as a whole word or at the start, not as part of other words (e.g., "Small")
    if ((/AllVariants|AllStates/i.test(storyName) || /^all$/i.test(storyName)) && !/Figma|figma/i.test(storyName)) {
      continue;
    }

    // Extract from args - find args block by counting braces (more reliable than regex)
    const argsStartMatch = storyContent.match(/args:\s*\{/);
    if (argsStartMatch) {
      const argsStartPos = argsStartMatch.index! + argsStartMatch[0].length;
      let braceCount = 1;
      let pos = argsStartPos;
      let argsEndPos = storyContent.length;

      while (pos < storyContent.length && braceCount > 0) {
        if (storyContent[pos] === '{') braceCount++;
        else if (storyContent[pos] === '}') {
          braceCount--;
          if (braceCount === 0) {
            argsEndPos = pos;
            break;
          }
        }
        pos++;
      }

      const argsContent = storyContent.substring(argsStartPos, argsEndPos);
      const propsList: string[] = [];
      let children: string | null = null;

      // Parse args
      const lines = argsContent.split('\n');
      let i = 0;
      while (i < lines.length) {
        const line = lines[i];
        const trimmed = line.trim().replace(/,$/, '');
        
        // Skip comments and empty lines
        if (!trimmed || trimmed.startsWith('//')) {
          i++;
          continue;
        }

        const keyMatch = trimmed.match(/^(\w+):\s*(.+)$/);
        if (keyMatch) {
          const key = keyMatch[1];
          let value = keyMatch[2].trim().replace(/,$/, '');

          // Handle RadioGroup's options array - use registry's sampleOptions
          if (componentName === 'RadioGroup' && key === 'options' && value === 'sampleOptions') {
            // Use sampleOptions from registry
            propsList.push(`${key}={sampleOptions}`);
            i++;
            continue;
          }

          // Handle Dropdown's options array - use registry's sampleOptions
          if (componentName === 'Dropdown' && key === 'options' && value === 'sampleOptions') {
            // Use sampleOptions from registry
            propsList.push(`${key}={sampleOptions}`);
            i++;
            continue;
          }

          // Handle RadioSelector's options array - use registry's baseOptions variable
          if (componentName === 'RadioSelector' && key === 'options') {
            if (value === 'baseOptions' || value.includes('baseOptions')) {
              // Use baseOptions from registry
              propsList.push(`${key}={baseOptions}`);
              i++;
              continue;
            } else if (value === 'sampleOptions') {
              // Use baseOptions for RadioSelector (which expects header/description format)
              propsList.push(`${key}={baseOptions}`);
              i++;
              continue;
            }
          }

          // Handle SegmentedTabs's items array - extract actual items inline
          if (componentName === 'SegmentedTabs' && key === 'items' && value.startsWith('[')) {
            const arrayLines: string[] = [value];
            let bracketDepth = 0;
            for (const char of value) {
              if (char === '[') bracketDepth++;
              if (char === ']') bracketDepth--;
            }
            let tempI = i + 1;
            while (tempI < lines.length && bracketDepth > 0) {
              const currentLine = lines[tempI].trim();
              arrayLines.push(currentLine);
              for (const char of currentLine) {
                if (char === '[') bracketDepth++;
                if (char === ']') bracketDepth--;
              }
              tempI++;
            }
            i = tempI - 1;
            const arrayLiteral = arrayLines.join(' ').replace(/,\s*$/, '').trim();
            const formattedArray = formatArrayLiteral(arrayLiteral);
            propsList.push(`${key}={${formattedArray}}`);
            continue;
          }

          // Handle ButtonGroup's buttons array - detect start and skip to end
          if (componentName === 'ButtonGroup' && key === 'buttons' && value.startsWith('[')) {
            // Use sampleButtons variable
            propsList.push(`${key}={sampleButtons}`);
            // Skip array content until we find the closing bracket
            let bracketDepth = 1;
            i++;
            while (i < lines.length && bracketDepth > 0) {
              const currentLine = lines[i];
              for (const char of currentLine) {
                if (char === '[') bracketDepth++;
                if (char === ']') bracketDepth--;
              }
              i++;
            }
            continue;
          }

          if (key === 'children') {
            const strMatch = value.match(/["']([^"']+)["']/);
            if (strMatch) {
              children = strMatch[1];
            }
          } else {
            if (value.startsWith("'")) {
              // Convert single quotes to double quotes for JSX
              const unquoted = value.slice(1, -1);
              propsList.push(`${key}="${unquoted}"`);
            } else if (value.startsWith('"')) {
              propsList.push(`${key}=${value}`);
            } else if (value === 'true') {
              // Include boolean true props (checked, disabled, error, indeterminate, etc.)
              propsList.push(key);
            } else if (value === 'false') {
              // Skip false values
            } else if (/^-?\d+\.?\d*$/.test(value)) {
              // Number props need curly braces in JSX
              propsList.push(`${key}={${value}}`);
            } else if (value.startsWith('[') || value.startsWith('{')) {
              // For complex objects/arrays, include as placeholder to preserve context
              if (value.startsWith('[')) {
                // Try to extract first item if it's an array of strings
                const firstItemMatch = value.match(/\[["']([^"']+)["']/);
                if (firstItemMatch) {
                  propsList.push(`${key}={[/* array with "${firstItemMatch[1]}" */]}`);
                } else {
                  propsList.push(`${key}={[/* ${key} array */]}`);
                }
              } else {
                propsList.push(`${key}={{/* ${key} object */}}`);
              }
            } else if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(value) && !value.startsWith("'") && !value.startsWith('"')) {
              // Variable references - output as JSX expression for react-live
              propsList.push(`${key}={${value}}`);
            } else if (!value.startsWith('[') && !value.startsWith('{')) {
              propsList.push(`${key}="${value}"`);
            }
          }
        }
        i++;
      }

      // Build code
      const propsStr = propsList.join(' ');
      let code: string;
      if (children) {
        code = `<${componentName} ${propsStr}>${children}</${componentName}>`;
      } else {
        code = `<${componentName} ${propsStr} />`;
      }
      
      // For components without patterns, even if code is minimal (e.g., missing options prop),
      // we should still extract the story using the story name
      // This handles cases like RadioGroup where options is a variable reference

      // Extract variant name from code props (not story name) - check before duplicates
      const variantMatch = code.match(/variant=["']([^"']+)["']/);
      const sizeMatch = code.match(/size=["']([^"']+)["']/);
      const orientationMatch = code.match(/orientation=["']([^"']+)["']/);
      // Check for boolean state props (checked, disabled, error, indeterminate)
      const hasChecked = /\bchecked\b/.test(code) && !/checked=["']/.test(code);
      const hasDisabled = /\bdisabled\b/.test(code) && !/disabled=["']/.test(code);
      const hasError = /\berror\b/.test(code) && !/error=["']/.test(code);
      const hasIndeterminate = /\bindeterminate\b/.test(code) && !/indeterminate=["']/.test(code);
      // Label-specific boolean props
      const hasMandatory = /\bmandatory\b/.test(code) && !/mandatory=["']/.test(code);
      const hasOptional = /\boptional\b/.test(code) && !/optional=["']/.test(code);
      const hasSuffixIcon = /\bsuffixIcon\b/.test(code) && !/suffixIcon=["']/.test(code);
      const stateMatch = hasChecked || hasDisabled || hasError || hasIndeterminate
        ? (hasIndeterminate ? 'indeterminate' : hasChecked ? 'checked' : hasDisabled ? 'disabled' : 'error')
        : null;
      const typeMatch = code.match(/type=["']([^"']+)["']/);
      const hasLeadingIcon = /leadingIcon=["']/.test(code);
      const hasTrailingIcon = /trailingIcon=["']/.test(code);
      const hasIconOnly = /iconPosition=["']only["']/.test(code);
      const hasInteraction = /\binteraction\b/.test(code);
      const hasValue = /value=["']/.test(code);
      const hasDefaultValue = /defaultValue=["']/.test(code);

      // Extract all variants first - don't filter early
      // Pattern filtering will happen later if needed
      const hasPatterns = componentPatterns[componentName] !== undefined;

      // Check duplicates - always use story name to prevent false positives
      const codeKey = code.replace(/\s+/g, '');
      // Always include story name in duplicate key to distinguish similar props with different names
      const duplicateKey = `${storyName}|${codeKey}`;
      if (seenCodes.has(duplicateKey)) {
        continue;
      }

      const variantKey = extractVariantKey(code, componentName);
      // Always include story name to distinguish similar variants with different story names
      const fullVariantKey = `${componentName}|${storyName}|${variantKey}`;
      if (seenVariantKeys.has(fullVariantKey)) {
        continue;
      }

      // Generate display name from props, not story name
      // Priority: story name patterns > icon variants > state > orientation > size > controlled > default
      let displayName: string | undefined;

      // For components WITHOUT Figma patterns, prioritize story names directly
      // Always use story name for components without patterns (don't check props first)
      if (!hasPatterns) {
        // Use story name as display name for components without patterns
        displayName = storyName.replace(/([A-Z])/g, ' $1').trim();
        if (storyName === 'WithDisabled') {
          displayName = 'With Disabled';
        } else if (storyName === 'WithDescription') {
          displayName = 'With Description';
        } else if (storyName === 'WithoutLabel') {
          displayName = 'Without Label';
        } else if (storyName === 'Small') {
          displayName = 'Small';
        } else if (storyName === 'Horizontal') {
          displayName = 'Horizontal';
        } else if (storyName === 'Vertical') {
          displayName = 'Vertical';
        } else if (storyName === 'Controlled') {
          displayName = 'Controlled';
        }
        // Skip prop-based logic for components without patterns - use story name directly
      }
      
      // For components WITH patterns, prioritize story names (before props)
      // This ensures story names are used even if props would suggest a different name
      // Label-specific handling - ALWAYS check story names first for Label
      if (componentName === 'Label') {
        if (storyName === 'Default') {
          displayName = 'Default';
        } else if (storyName === 'WithSuffixIcon' || storyName === 'With Suffix Icon') {
          displayName = 'With Suffix Icon';
        } else if (storyName === 'Optional') {
          displayName = 'Optional';
        } else if (storyName === 'OptionalWithIcon' || storyName === 'Optional With Icon') {
          displayName = 'Optional With Icon';
        } else if (storyName === 'Mandatory') {
          displayName = 'Mandatory';
        } else if (storyName === 'MandatoryWithIcon' || storyName === 'Mandatory With Icon') {
          displayName = 'Mandatory With Icon';
        } else if (storyName === 'CustomIcon' || storyName === 'Custom Icon') {
          displayName = 'Custom Icon';
        } else if (storyName === 'LongText' || storyName === 'Long Text') {
          displayName = 'Long Text';
        }
      } else if (hasPatterns) {
        // Check other component story names
        if (storyName === 'Default') {
          displayName = 'Default';
        } else if (storyName === 'Small') {
          displayName = 'Small';
        } else if (storyName === 'Checked') {
          displayName = 'Checked';
        } else if (storyName === 'Indeterminate') {
          displayName = 'Indeterminate';
        } else if (storyName === 'Error') {
          displayName = 'Error';
        } else if (storyName === 'Disabled') {
          displayName = 'Disabled';
        } else if (storyName === 'DisabledChecked' || storyName === 'Disabled Checked') {
          displayName = 'Disabled Checked';
        } else if (storyName === 'WithDescription' || storyName === 'With Description') {
          displayName = 'With Description';
        }
      }
      
      // If displayName not set yet, check story name patterns (for components with patterns)
      if (!displayName) {
        // Check for size-only story names first (before variant matching)
        if (/^(ExtraSmall|Small|Medium|Large|ExtraLarge|ExtraExtraLarge|Xs|Sm|Md|Lg|Xl|Xxl)$/i.test(storyName)) {
          displayName = storyName.replace(/([A-Z])/g, ' $1').trim();
          // Handle common size name mappings
          if (storyName === 'ExtraSmall' || storyName === 'Xs') {
            displayName = 'Extra Small';
          } else if (storyName === 'ExtraLarge' || storyName === 'Xl') {
            displayName = 'Extra Large';
          } else if (storyName === 'ExtraExtraLarge' || storyName === 'Xxl') {
            displayName = '2X Large';
          }
        } else if (storyName === 'WithDisabled' || storyName === 'With Disabled') {
          displayName = 'With Disabled';
        } else if (storyName === 'WithDescription' || storyName === 'With Description') {
          displayName = 'With Description';
        } else if (storyName === 'WithoutLabel' || storyName === 'Without Label') {
          displayName = 'Without Label';
        } else if (storyName === 'Controlled') {
          displayName = 'Controlled';
        } else if (storyName === 'Horizontal') {
          displayName = 'Horizontal';
        } else if (storyName === 'Vertical') {
          displayName = 'Vertical';
        } else if (storyName === 'Small') {
          displayName = 'Small';
        } else if (storyName === 'Default') {
          displayName = 'Default';
        } else if (storyName === 'Checked') {
          displayName = 'Checked';
        } else if (storyName === 'Indeterminate') {
          displayName = 'Indeterminate';
        } else if (storyName === 'Error') {
          displayName = 'Error';
        } else if (storyName === 'Disabled') {
          displayName = 'Disabled';
        } else if (storyName === 'DisabledChecked' || storyName === 'Disabled Checked') {
          displayName = 'Disabled Checked';
        } else if (storyName === 'WithSuffixIcon' || storyName === 'With Suffix Icon') {
          displayName = 'With Suffix Icon';
        } else if (storyName === 'WithCustomIcon' || storyName === 'With Custom Icon') {
          displayName = 'With Custom Icon';
        } else if (storyName === 'Optional') {
          displayName = 'Optional';
        } else if (storyName === 'OptionalWithIcon' || storyName === 'Optional With Icon') {
          displayName = 'Optional With Icon';
        } else if (storyName === 'Mandatory') {
          displayName = 'Mandatory';
        } else if (storyName === 'MandatoryWithIcon' || storyName === 'Mandatory With Icon') {
          displayName = 'Mandatory With Icon';
        } else if (storyName === 'CustomIcon' || storyName === 'Custom Icon') {
          displayName = 'Custom Icon';
        } else if (storyName === 'LongText' || storyName === 'Long Text') {
          displayName = 'Long Text';
        } else if (storyName === 'WithLeadingIcon') {
          displayName = 'With Leading Icon';
        } else if (storyName === 'WithTrailingIcon') {
          displayName = 'With Trailing Icon';
        } else if (storyName === 'IconOnly') {
          displayName = 'Icon Only';
        }
      }
      
      // If still no displayName, check props
      // Skip props-based logic for Label and Input - story names should always be used
      // For Input, prioritize story names over type props to avoid "Email" instead of "With Custom Icon"
      if (!displayName && componentName !== 'Label' && componentName !== 'Input') {
        // Label-specific prop combinations (for other components that might have similar props)
        if (hasMandatory && hasSuffixIcon) {
          displayName = 'Mandatory With Icon';
        } else if (hasOptional && hasSuffixIcon) {
          displayName = 'Optional With Icon';
        } else if (hasMandatory) {
          displayName = 'Mandatory';
        } else if (hasOptional) {
          displayName = 'Optional';
        } else if (hasSuffixIcon) {
          displayName = 'With Suffix Icon';
        } else if (hasIconOnly) {
          displayName = 'Icon Only';
        } else if (hasLeadingIcon && hasTrailingIcon) {
          displayName = 'With Both Icons';
        } else if (hasLeadingIcon && !hasTrailingIcon) {
          displayName = 'With Leading Icon';
        } else if (hasTrailingIcon && !hasLeadingIcon) {
          displayName = 'With Trailing Icon';
        } else if (hasInteraction) {
          displayName = 'Interactive';
        } else if (sizeMatch && !variantMatch && !hasLeadingIcon && !hasTrailingIcon && !hasIconOnly) {
          // Size-only variants (no variant, icons, or other props) - use size as primary identifier
          const size = sizeMatch[1];
          displayName = size.charAt(0).toUpperCase() + size.slice(1);
          if (size === 'xs') displayName = 'Extra Small';
          else if (size === 'xl') displayName = 'Extra Large';
          else if (size === 'xxl') displayName = '2X Large';
        } else if (variantMatch) {
          const variant = variantMatch[1];
          displayName = variant.charAt(0).toUpperCase() + variant.slice(1);
          if (stateMatch) {
            const stateName = typeof stateMatch === 'string' ? stateMatch : stateMatch[1];
            displayName += ` ${stateName.charAt(0).toUpperCase() + stateName.slice(1)}`;
          }
        } else if (stateMatch) {
          // For components without variant prop, use state as primary identifier
          const stateName = typeof stateMatch === 'string' ? stateMatch : stateMatch[1];
          if (hasIndeterminate) {
            displayName = 'Indeterminate';
          } else if (hasChecked) {
            displayName = 'Checked';
          } else if (hasDisabled) {
            displayName = 'Disabled';
          } else if (hasError) {
            displayName = 'Error';
          } else {
            displayName = stateName.charAt(0).toUpperCase() + stateName.slice(1);
          }
        } else if (/description=["']/.test(code)) {
          displayName = 'With Description';
        } else if (orientationMatch && !sizeMatch) {
          // Orientation variants (but not if size is the primary differentiator)
          displayName = orientationMatch[1].charAt(0).toUpperCase() + orientationMatch[1].slice(1);
        } else if (sizeMatch && !orientationMatch) {
          // Size variants (but not if orientation is the primary differentiator)
          displayName = sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1);
        } else if (hasValue) {
          displayName = 'Controlled';
        } else if (hasDefaultValue && storyName !== 'Default') {
          displayName = 'Default';
        } else if (typeMatch) {
          const type = typeMatch[1];
          displayName = type.charAt(0).toUpperCase() + type.slice(1);
        }
      }
      
      // For Input component, always use story name if available (before falling back to type props)
      if (!displayName && componentName === 'Input') {
        // Use story name as display name for Input component
        displayName = storyName.replace(/([A-Z])/g, ' $1').trim();
        // Handle common Input story name patterns
        if (storyName === 'WithCustomIcon') {
          displayName = 'With Custom Icon';
        } else if (storyName === 'WithSuffixIcon') {
          displayName = 'With Suffix Icon';
        } else if (storyName === 'MandatoryWithIcon') {
          displayName = 'Mandatory With Icon';
        } else if (storyName === 'OptionalWithIcon') {
          displayName = 'Optional With Icon';
        }
      }
      
      // Ensure displayName is set - fallback to story name
      // For Label, story names should already be handled above, but add fallback just in case
      if (!displayName) {
        // Label-specific fallback
        if (componentName === 'Label') {
          if (storyName === 'WithSuffixIcon' || storyName === 'With Suffix Icon') {
            displayName = 'With Suffix Icon';
          } else if (storyName === 'Optional') {
            displayName = 'Optional';
          } else if (storyName === 'OptionalWithIcon' || storyName === 'Optional With Icon') {
            displayName = 'Optional With Icon';
          } else if (storyName === 'Mandatory') {
            displayName = 'Mandatory';
          } else if (storyName === 'MandatoryWithIcon' || storyName === 'Mandatory With Icon') {
            displayName = 'Mandatory With Icon';
          } else if (storyName === 'CustomIcon' || storyName === 'Custom Icon') {
            displayName = 'Custom Icon';
          } else if (storyName === 'LongText' || storyName === 'Long Text') {
            displayName = 'Long Text';
          } else {
            displayName = storyName.replace(/([A-Z])/g, ' $1').trim();
          }
        } else {
          displayName = storyName.replace(/([A-Z])/g, ' $1').trim();
          if (!displayName) displayName = storyName;
          // Handle common story name patterns
          if (storyName === 'WithDisabled') {
            displayName = 'With Disabled';
          } else if (storyName === 'WithDescription') {
            displayName = 'With Description';
          } else if (storyName === 'WithoutLabel') {
            displayName = 'Without Label';
          }
        }
      }

      // Extract all variants by default - only filter if explicitly configured
      // This ensures all variants are extracted, not just Figma-compliant ones
      const shouldFilterByPatterns = process.env.FILTER_FIGMA_ONLY === 'true';
      if (shouldFilterByPatterns && hasPatterns && !isFigmaVariantName(displayName, componentName)) {
        // Debug: log what was filtered out
        if (process.env.NODE_ENV === 'development') {
          console.log(`[${componentName}] Filtered out: ${displayName} (story: ${storyName})`);
        }
        continue;
      }
      // Default: extract all variants regardless of Figma patterns

      seenCodes.add(duplicateKey);
      seenVariantKeys.add(fullVariantKey);

      examples.push({ name: displayName, code });

      // Debug: log what was added
      if (process.env.NODE_ENV === 'development' && (componentName === 'Badge' || componentName === 'Label')) {
        console.log(`[${componentName}] Added example: ${displayName} -> ${code.substring(0, 60)}...`);
      }
    }

    // Extract from render functions (for FigmaVariants, AllVariants, Sizes, Variants, States, etc.)
    // Extract from all stories with render functions - don't skip based on patterns
    // For showcase stories like CircularButtons, extract the entire render function as a single example
    // This should be checked for every story, regardless of whether it has args
    if (/render:\s*\([^)]*\)\s*=>/.test(storyContent)) {
      // Check if this is a showcase story (contains multiple components for demonstration)
      const isShowcaseStory = /CircularButtons|FigmaVariants|AllVariants|AllStates|AllSizes|Sizes|Variants|States|Showcase|WithIcons|InputTypes/i.test(storyName);
      
      // Match render function - handle arrow functions with JSX return
      // Pattern: render: () => ( ... JSX ... )
      const renderStartMatch = storyContent.match(/render:\s*\([^)]*\)\s*=>\s*\(/);
        if (renderStartMatch) {
          const renderStartPos = renderStartMatch.index! + renderStartMatch[0].length;
          // Find matching closing parenthesis by counting
          let parenCount = 1;
          let pos = renderStartPos;
          let renderEndPos = storyContent.length;

          while (pos < storyContent.length && parenCount > 0) {
            if (storyContent[pos] === '(') parenCount++;
            else if (storyContent[pos] === ')') {
              parenCount--;
              if (parenCount === 0) {
                renderEndPos = pos;
                break;
              }
            }
            pos++;
          }

          const renderContent = storyContent.substring(renderStartPos, renderEndPos);
          
          // For showcase stories, extract the entire render function as a single example
          
          if (isShowcaseStory) {
            // For showcase stories, extract all individual components (not just the first one)
            // This allows "All Sizes" to show all size variants, not just the first
            const componentPattern = new RegExp(`<${componentName}(?:\\s+[^>]*)?(?:>.*?</${componentName}>|/>)`, 'gs');
            const componentMatches = Array.from(renderContent.matchAll(componentPattern));

            for (const compMatch of componentMatches) {
              let code = compMatch[0].trim().replace(/\s+/g, ' ');

              // Normalize JSX: convert single quotes to double quotes in props
              code = code.replace(/(\w+)=[']([^']+)[']/g, '$1="$2"');

              // Extract size/variant to create a meaningful name
              const sizeMatch = code.match(/size=["']([^"']+)["']/);
              const variantMatch = code.match(/variant=["']([^"']+)["']/);
              
              let exampleName: string;
              if (sizeMatch) {
                // For "AllSizes" showcase, use just the size name (e.g., "SM", "MD")
                // For other showcase stories, prefix with story name
                if (storyName === 'AllSizes') {
                  exampleName = sizeMatch[1].toUpperCase();
                } else {
                  const size = sizeMatch[1].toUpperCase();
                  exampleName = `${storyName.replace(/([A-Z])/g, ' $1').trim()} - ${size}`;
                }
              } else if (variantMatch) {
                const variant = variantMatch[1].charAt(0).toUpperCase() + variantMatch[1].slice(1);
                if (storyName === 'AllSizes') {
                  exampleName = variant;
                } else {
                  exampleName = `${storyName.replace(/([A-Z])/g, ' $1').trim()} - ${variant}`;
                }
              } else {
                exampleName = storyName.replace(/([A-Z])/g, ' $1').trim();
              }

              // Check if we've already added this exact code
              if (!seenCodes.has(code)) {
                seenCodes.add(code);
                examples.push({ 
                  name: exampleName, 
                  code: code 
                });
              }
            }
            // Skip the default individual component extraction below for showcase stories
            continue;
          }
          
          // For non-showcase stories, extract individual components
          // Match component tags - handle both self-closing and with children
          const componentPattern = new RegExp(`<${componentName}(?:\\s+[^>]*)?(?:>.*?</${componentName}>|/>)`, 'gs');
          const componentMatches = Array.from(renderContent.matchAll(componentPattern));

          for (const compMatch of componentMatches) {
            let code = compMatch[0].trim().replace(/\s+/g, ' ');

            // Normalize JSX: convert single quotes to double quotes in props
            code = code.replace(/(\w+)=[']([^']+)[']/g, '$1="$2"');

            // Extract variant name from props first to check if it's valid
            const variantMatch = code.match(/variant=["']([^"']+)["']/);
            const sizeMatch = code.match(/size=["']([^"']+)["']/);
            const typeMatch = code.match(/type=["']([^"']+)["']/);
            // Check for boolean state props (checked, disabled, error, indeterminate)
            const hasChecked = /\bchecked\b/.test(code) && !/checked=["']/.test(code);
            const hasDisabled = /\bdisabled\b/.test(code) && !/disabled=["']/.test(code);
            const hasError = /\berror\b/.test(code) && !/error=["']/.test(code);
            const hasIndeterminate = /\bindeterminate\b/.test(code) && !/indeterminate=["']/.test(code);
            const stateMatch = hasChecked || hasDisabled || hasError || hasIndeterminate
              ? (hasIndeterminate ? 'indeterminate' : hasChecked ? 'checked' : hasDisabled ? 'disabled' : 'error')
              : null;
            const hasLeadingIcon = /leadingIcon=["']/.test(code);
            const hasTrailingIcon = /trailingIcon=["']/.test(code);
            const hasIconOnly = /iconPosition=["']only["']/.test(code);
            const hasInteraction = /\binteraction\b/.test(code);

            // Extract all variants from render functions - don't filter early
            // Pattern filtering will happen later if needed

            // Check duplicates - always use story name to prevent false positives
            const codeKey = code.replace(/\s+/g, '');
            const duplicateKey = `${storyName}|${codeKey}`;
            if (seenCodes.has(duplicateKey)) continue;

            const variantKey = extractVariantKey(code, componentName);
            const fullVariantKey = `${componentName}|${storyName}|${variantKey}`;
            if (seenVariantKeys.has(fullVariantKey)) continue;

            let displayName: string;
            // For render function stories, derive display name from props first
            // Only use story name as fallback if props don't provide enough info
            // Priority: icon-only > icon variants > interaction > variant > type > size > state
            
            // Check if this is a circular button (has rounded-full class)
            const isCircular = /rounded-full/.test(code);
            
            if (hasIconOnly) {
              // For icon-only buttons, include variant and size info for uniqueness
              let baseName = isCircular ? 'Circular Icon Only' : 'Icon Only';
              if (variantMatch) {
                const variant = variantMatch[1].charAt(0).toUpperCase() + variantMatch[1].slice(1);
                baseName += ` (${variant}`;
                if (sizeMatch) {
                  const size = sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1);
                  baseName += ` ${size})`;
                } else {
                  baseName += ')';
                }
              } else if (sizeMatch) {
                const size = sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1);
                baseName += ` (${size})`;
              }
              displayName = baseName;
            } else if (hasLeadingIcon && hasTrailingIcon) {
              displayName = 'With Both Icons';
            } else if (hasLeadingIcon && !hasTrailingIcon) {
              displayName = 'With Leading Icon';
            } else if (hasTrailingIcon && !hasLeadingIcon) {
              displayName = 'With Trailing Icon';
            } else if (hasInteraction) {
              displayName = 'Interactive';
            } else if (variantMatch) {
              const variant = variantMatch[1];
              displayName = variant.charAt(0).toUpperCase() + variant.slice(1);
              if (isCircular && hasIconOnly) {
                displayName += ' Circular';
              }
              if (sizeMatch) {
                const size = sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1);
                displayName += ` ${size}`;
              }
              if (stateMatch) {
                const stateName = typeof stateMatch === 'string' ? stateMatch : stateMatch[1];
                displayName += ` ${stateName.charAt(0).toUpperCase() + stateName.slice(1)}`;
              }
            } else if (stateMatch) {
              // For components without variant prop, use state as primary identifier
              const stateName = typeof stateMatch === 'string' ? stateMatch : stateMatch[1];
              if (hasIndeterminate) {
                displayName = 'Indeterminate';
              } else if (hasChecked) {
                displayName = 'Checked';
              } else if (hasDisabled) {
                displayName = 'Disabled';
              } else if (hasError) {
                displayName = 'Error';
              } else {
                displayName = stateName.charAt(0).toUpperCase() + stateName.slice(1);
              }
            } else if (typeMatch) {
              const type = typeMatch[1];
              displayName = type.charAt(0).toUpperCase() + type.slice(1);
            } else if (sizeMatch) {
              // Size-only variants
              const size = sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1);
              displayName = isCircular ? `Circular ${size}` : size;
            } else {
              // Fallback to story name only if we can't determine a meaningful name from props
              // For showcase stories like CircularButtons, use story name as prefix
              if (storyName === 'CircularButtons' && isCircular) {
                displayName = 'Circular Buttons';
              } else {
                // Skip if we can't determine a meaningful name from props
                continue;
              }
            }

            // Extract all variants from render functions by default - only filter if explicitly configured
            // Render functions often contain multiple variants that should all be shown
            const shouldFilterRenderVariants = process.env.FILTER_FIGMA_ONLY === 'true';
            if (shouldFilterRenderVariants) {
              const hasPatternsForRender = componentPatterns[componentName] !== undefined;
              if (hasPatternsForRender && !isFigmaVariantName(displayName, componentName)) {
                continue;
              }
            }
            // Default: include all render function variants

            // Check for duplicate display names - if same display name exists, make it unique
            // This prevents multiple buttons from CircularButtons story all being named "Circular Buttons"
            let finalDisplayName = displayName;
            const existingDisplayNames = new Set(examples.map(e => e.name));
            if (existingDisplayNames.has(finalDisplayName)) {
              // Make display name unique by appending variant/size/icon info
              const parts: string[] = [];
              if (variantMatch) {
                parts.push(variantMatch[1].charAt(0).toUpperCase() + variantMatch[1].slice(1));
              }
              if (sizeMatch) {
                parts.push(sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1));
              }
              const iconMatch = code.match(/icon=["']([^"']+)["']/);
              if (iconMatch && parts.length === 0) {
                // Only add icon if we don't have variant/size
                parts.push(iconMatch[1].charAt(0).toUpperCase() + iconMatch[1].slice(1));
              }
              
              if (parts.length > 0) {
                finalDisplayName = `${displayName} (${parts.join(' ')})`;
              } else {
                // Fallback: add index
                let counter = 1;
                while (existingDisplayNames.has(`${displayName} ${counter}`)) {
                  counter++;
                }
                finalDisplayName = `${displayName} ${counter}`;
              }
            }

            seenCodes.add(codeKey);
            seenVariantKeys.add(variantKey);

            examples.push({ name: finalDisplayName, code });
          }
        }
      }
    }

  return examples;
}

/**
 * Extract description from Storybook meta
 */
function extractDescriptionFromStory(content: string): string {
  // Try to get from docs.description.component
  const descMatch = content.match(/description:\s*\{\s*component:\s*["']([^"']+)["']/);
  if (descMatch) {
    return descMatch[1];
  }

  // Fallback
  return 'Component';
}

/**
 * Get component metadata
 */
export function getComponentMetadata(componentName: string): ComponentDoc | undefined {
  // In development, always re-extract to pick up changes immediately
  // In production, use cache for performance
  if (process.env.NODE_ENV === 'development') {
    metadataCache.delete(componentName);
  } else if (metadataCache.has(componentName)) {
    return metadataCache.get(componentName);
  }

  // Find component file
  const componentPath = findComponentFile(componentName);
  if (!componentPath) {
    return undefined;
  }

  // Find story file
  const storyPath = findStoryFile(componentName);

  // Extract props (prefer from component, fallback to story)
  let props: Record<string, any> = {};
  if (componentPath) {
    props = extractPropsFromComponent(componentPath, componentName);
  }
  if (storyPath) {
    const storyContent = fs.readFileSync(storyPath, 'utf-8');
    const storyProps = extractPropsFromStory(storyContent);
    // Merge story props (they have descriptions)
    for (const [key, value] of Object.entries(storyProps)) {
      if (value.description || value.default !== undefined) {
        props[key] = { ...props[key], ...value };
      }
    }
  }

  // Extract description
  let description = `${componentName} component`;
  if (storyPath) {
    const storyContent = fs.readFileSync(storyPath, 'utf-8');
    description = extractDescriptionFromStory(storyContent);
  }

  // Extract examples
  let examples: Array<{ name: string; code: string }> = [];
  if (storyPath) {
    examples = extractExamplesFromStory(storyPath, componentName);
  }

  // Only add default if component has explicit Default pattern and no examples found
  // Don't add default for components without Figma patterns
  if (examples.length === 0) {
    const hasDefaultPattern = isFigmaVariantName('Default', componentName);
    // Check if component has any Figma patterns defined
    const hasPatterns = componentPatterns[componentName] !== undefined;
    if (hasDefaultPattern && hasPatterns) {
      examples.push({
        name: 'Default',
        code: `<${componentName} />`,
      });
    }
  }

  const doc: ComponentDoc = {
    description,
    import: `import { ${componentName} } from '@chetanft/design_system';`,
    props,
    examples,
  };

  // Cache result
  metadataCache.set(componentName, doc);

  return doc;
}

/**
 * Get all component names from exports
 */
export function getAllComponentNames(): string[] {
  if (componentNamesCache !== null) {
    return componentNamesCache;
  }

  if (!fs.existsSync(componentsIndexPath)) {
    return [];
  }

  const content = fs.readFileSync(componentsIndexPath, 'utf-8');
  const componentNames = new Set<string>();

  // Extract from export * statements
  const exportStarMatches = content.matchAll(/export\s+\*\s+from\s+['"]([^'"]+)['"]/g);
  for (const match of exportStarMatches) {
    const exportPath = match[1];
    const componentName = exportPath.split('/').pop() || '';
    if (componentName && componentName[0] === componentName[0].toUpperCase()) {
      componentNames.add(componentName);
    }
  }

  // Extract from named exports
  const namedExportMatches = content.matchAll(/export\s+\{\s*([^}]+)\s*\}\s+from/g);
  for (const match of namedExportMatches) {
    const exports = match[1].split(',').map((e) => e.trim().split(/\s+as\s+/)[0].trim());
    for (const exp of exports) {
      if (exp && exp[0] === exp[0].toUpperCase() && !exp.includes('Legacy')) {
        componentNames.add(exp);
      }
    }
  }

  // Filter out non-components
  const skipNames = ['cn', 'ThemeProvider', 'useTheme', 'ThemeSwitch', 'Templates', 'templates'];
  const filtered = Array.from(componentNames).filter((name) => !skipNames.includes(name)).sort();

  // Cache result
  componentNamesCache = filtered;
  return filtered;
}

// Re-export for compatibility
export function getComponentDoc(name: string): ComponentDoc | undefined {
  return getComponentMetadata(name);
}

